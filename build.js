#!/usr/bin/env node
// Production Build Script
// This script prepares the application for production deployment
// It injects environment variables at build time for security

const fs = require('fs');
const path = require('path');

class ProductionBuilder {
    constructor() {
        this.envVars = this.loadEnvironmentVariables();
        this.outputDir = './dist';
        this.sourceDir = './';
    }

    loadEnvironmentVariables() {
        // Try to load from .env file
        const envPath = path.join(process.cwd(), '.env');
        
        if (!fs.existsSync(envPath)) {
            console.error('‚ùå .env file not found. Please create one from .env.example');
            process.exit(1);
        }

        const envContent = fs.readFileSync(envPath, 'utf8');
        const envVars = {};

        envContent.split('\n').forEach(line => {
            if (line.trim() && !line.startsWith('#')) {
                const [key, ...valueParts] = line.split('=');
                const value = valueParts.join('=').trim();
                envVars[key.trim()] = value;
            }
        });

        return envVars;
    }

    createBuildConfig() {
        const config = {
            FIREBASE_API_KEY: this.envVars.FIREBASE_API_KEY,
            FIREBASE_AUTH_DOMAIN: this.envVars.FIREBASE_AUTH_DOMAIN,
            FIREBASE_PROJECT_ID: this.envVars.FIREBASE_PROJECT_ID,
            FIREBASE_STORAGE_BUCKET: this.envVars.FIREBASE_STORAGE_BUCKET,
            FIREBASE_MESSAGING_SENDER_ID: this.envVars.FIREBASE_MESSAGING_SENDER_ID,
            FIREBASE_APP_ID: this.envVars.FIREBASE_APP_ID,
            FIREBASE_MEASUREMENT_ID: this.envVars.FIREBASE_MEASUREMENT_ID
        };

        return `
// Build-time Environment Configuration
// Generated at: ${new Date().toISOString()}
// DO NOT EDIT - This file is automatically generated

window.ENV_CONFIG = ${JSON.stringify(config, null, 2)};

console.log('üîß Production environment configuration loaded');
`;
    }

    copyFiles() {
        console.log('üìÅ Creating build directory...');
        
        if (!fs.existsSync(this.outputDir)) {
            fs.mkdirSync(this.outputDir, { recursive: true });
        }

        // Copy all files except .env and node_modules
        const filesToCopy = [
            'index.html',
            'assets/',
            'admin/',
            'events/',
            'firebase.json',
            'firestore.rules',
            'firestore.indexes.json'
        ];

        filesToCopy.forEach(file => {
            const srcPath = path.join(this.sourceDir, file);
            const destPath = path.join(this.outputDir, file);

            if (fs.existsSync(srcPath)) {
                if (fs.statSync(srcPath).isDirectory()) {
                    this.copyDirectory(srcPath, destPath);
                } else {
                    fs.copyFileSync(srcPath, destPath);
                }
                console.log(`‚úÖ Copied: ${file}`);
            }
        });
    }

    copyDirectory(src, dest) {
        if (!fs.existsSync(dest)) {
            fs.mkdirSync(dest, { recursive: true });
        }

        const files = fs.readdirSync(src);

        files.forEach(file => {
            const srcFile = path.join(src, file);
            const destFile = path.join(dest, file);

            if (fs.statSync(srcFile).isDirectory()) {
                this.copyDirectory(srcFile, destFile);
            } else {
                fs.copyFileSync(srcFile, destFile);
            }
        });
    }

    injectEnvironmentConfig() {
        console.log('üîß Injecting environment configuration...');
        
        const configScript = this.createBuildConfig();
        const configPath = path.join(this.outputDir, 'assets/js/env-config.generated.js');
        
        // Ensure directory exists
        const configDir = path.dirname(configPath);
        if (!fs.existsSync(configDir)) {
            fs.mkdirSync(configDir, { recursive: true });
        }

        fs.writeFileSync(configPath, configScript);
        console.log('‚úÖ Environment configuration injected');

        // Update HTML files to load the generated config
        this.updateHtmlFiles();
    }

    updateHtmlFiles() {
        const htmlFiles = [
            path.join(this.outputDir, 'index.html'),
            path.join(this.outputDir, 'admin/login.html'),
            path.join(this.outputDir, 'admin/dashboard.html'),
            path.join(this.outputDir, 'events/details.html')
        ];

        htmlFiles.forEach(filePath => {
            if (fs.existsSync(filePath)) {
                let content = fs.readFileSync(filePath, 'utf8');
                
                // Inject the generated config before env-loader
                content = content.replace(
                    /<!-- Environment Variables Loader -->/g,
                    `<!-- Generated Environment Config -->
    <script src="../assets/js/env-config.generated.js"></script>
    
    <!-- Environment Variables Loader -->`
                );

                // Fix paths for files in subdirectories
                if (filePath.includes('admin/') || filePath.includes('events/')) {
                    content = content.replace(
                        /src="\.\.\/assets\/js\/env-config\.generated\.js"/g,
                        'src="../assets/js/env-config.generated.js"'
                    );
                } else {
                    content = content.replace(
                        /src="\.\.\/assets\/js\/env-config\.generated\.js"/g,
                        'src="assets/js/env-config.generated.js"'
                    );
                }

                fs.writeFileSync(filePath, content);
                console.log(`‚úÖ Updated: ${path.relative(this.outputDir, filePath)}`);
            }
        });
    }

    build() {
        console.log('üöÄ Starting production build...');
        console.log('================================');

        try {
            this.copyFiles();
            this.injectEnvironmentConfig();
            
            console.log('================================');
            console.log('‚úÖ Build completed successfully!');
            console.log(`üì¶ Output directory: ${this.outputDir}`);
            console.log('üöÄ Ready for deployment');
            
        } catch (error) {
            console.error('‚ùå Build failed:', error.message);
            process.exit(1);
        }
    }
}

// Run build if called directly
if (require.main === module) {
    const builder = new ProductionBuilder();
    builder.build();
}

module.exports = ProductionBuilder;